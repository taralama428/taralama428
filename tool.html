<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced CSV Data Analysis Workbench</title>
    <!-- Load PapaParse for fast CSV parsing -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <!-- Load Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        :root {
            --primary-color: #3b82f6; /* Blue-500 */
            --primary-light: #60a5fa; /* Blue-400 */
            --background-color: #f3f4f6; /* Gray-100 */
            --card-background: #ffffff;
            --text-color: #1f2937; /* Gray-800 */
            --border-color: #e5e7eb; /* Gray-200 */
            --anomaly-color: #ef4444; /* Red-500 */
            --success-color: #10b981; /* Green-500 */
            font-family: 'Inter', sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 10px;
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.25rem;
        }

        /* --- Card Styles --- */
        .card {
            background-color: var(--card-background);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }
        
        .grid-layout {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
            color: var(--primary-color);
        }

        /* --- Form Elements --- */
        label {
            display: block;
            font-weight: 500;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        input[type="file"], input[type="text"], select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus, select:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        button {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover:not(:disabled) {
            background-color: var(--primary-light);
            transform: translateY(-1px);
        }
        
        button:disabled {
            background-color: #9ca3af; /* Gray-400 */
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* --- Table Styles --- */
        .table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
        }

        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        tr:nth-child(even) {
            background-color: #f9fafb; /* Gray-50 */
        }
        
        .anomaly-row {
            background-color: #fee2e2 !important; /* Red-100 */
            color: var(--anomaly-color);
            font-weight: 500;
        }

        /* --- Badges and Status --- */
        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 9999px;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .badge-anomaly {
            background-color: var(--anomaly-color);
            color: white;
        }
        .badge-total {
            background-color: var(--primary-color);
            color: white;
        }
        .badge-status {
             background-color: var(--success-color);
             color: white;
        }

        .status-message {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 8px;
            font-weight: 500;
            transition: opacity 0.3s;
        }
        .error {
            background-color: #fee2e2;
            color: var(--anomaly-color);
            border: 1px solid var(--anomaly-color);
        }
        .success {
            background-color: #d1fae5;
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            h1 {
                font-size: 1.75rem;
            }
            .grid-layout {
                grid-template-columns: 1fr;
            }
            th, td {
                padding: 8px 10px;
            }
            .table-container {
                max-height: 300px;
            }
            .button-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“Š Advanced CSV Data Analysis Workbench</h1>

        <!-- 1. CSV Upload & Configuration -->
        <div id="upload-card" class="card">
            <h2 class="section-title">1. Upload & Configuration</h2>
            <div class="grid-layout">
                <div>
                    <label for="csv-file">Upload CSV File:</label>
                    <input type="file" id="csv-file" accept=".csv" required>
                </div>
                <div>
                    <label for="delimiter">Delimiter:</label>
                    <input type="text" id="delimiter" value="," maxlength="1">
                </div>
                <div>
                    <label for="has-header">Data includes Header Row?</label>
                    <select id="has-header">
                        <option value="true">Yes, first row is header</option>
                        <option value="false">No header row</option>
                    </select>
                </div>
            </div>
            <button onclick="processFile()">Analyze Data</button>
            <div id="status-message" class="status-message hidden" style="margin-top: 15px;"></div>
        </div>
        
        <div id="main-workbench" style="display: none;">
            <!-- 2. Data Preview & Type Detection -->
            <div class="card">
                <h2 class="section-title">2. Data Preview (<span id="total-rows-badge" class="badge badge-total">0 Rows</span>)</h2>
                <div id="column-types" style="margin-bottom: 15px;"></div>
                <div class="table-container">
                    <table id="data-preview-table"></table>
                </div>
            </div>

            <div class="grid-layout">
                <!-- 3. Descriptive Statistics -->
                <div class="card" id="stats-card">
                    <h2 class="section-title">3. Descriptive Statistics</h2>
                    <select id="stat-column-select" onchange="renderStatistics()"></select>
                    <div id="statistics-output">Select a numeric or categorical column above.</div>
                </div>

                <!-- 8. Visualizations (Chart) -->
                <div class="card" id="chart-card">
                    <h2 class="section-title">8. Visualization</h2>
                    <select id="chart-column-select" onchange="renderVisualization()"></select>
                    <div style="height: 300px; width: 100%; margin-top: 15px;">
                        <canvas id="data-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- 4. Anomaly Detection -->
            <div class="card">
                <h2 class="section-title">4. Anomaly Detection & Results</h2>
                <div class="grid-layout">
                    <div>
                        <label for="anomaly-column-select">Numeric Column to Analyze:</label>
                        <select id="anomaly-column-select"></select>
                    </div>
                    <div>
                        <label for="anomaly-method">Detection Method:</label>
                        <select id="anomaly-method">
                            <option value="IQR">IQR Method (1.5x IQR Rule)</option>
                            <option value="ZSCORE">Z-score Method (Abs Z > 3)</option>
                            <option value="BOTH">Both (Flag if either detects)</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: flex-end;">
                        <button onclick="detectAnomalies()">Run Anomaly Detection</button>
                    </div>
                </div>

                <div id="anomaly-results" style="margin-top: 20px; display: none;">
                    <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 10px;">
                        Anomalies Found: <span id="anomaly-count-badge" class="badge badge-anomaly">0</span>
                    </h3>
                    <div class="button-group" style="margin-bottom: 15px;">
                        <button onclick="downloadAnomalies()">Download Anomalies as CSV</button>
                    </div>
                    <div class="table-container">
                        <table id="anomaly-table"></table>
                    </div>
                </div>
            </div>

            <!-- 5. Filtering -->
            <div class="card">
                <h2 class="section-title">5. Data Filtering</h2>
                <label for="filter-expression">Filter Expression (e.g., `Age > 30 && Country === "USA"`):</label>
                <input type="text" id="filter-expression" placeholder='e.g., Age > 30 && Name.includes("John")'>
                <div class="button-group">
                    <button onclick="applyFilter()">Apply Filter</button>
                    <button onclick="resetFilter()">Reset</button>
                </div>
                
                <div id="filter-results" style="margin-top: 20px; display: none;">
                    <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 10px;">
                        Filtered Rows: <span id="filtered-count-badge" class="badge badge-status">0</span>
                    </h3>
                    <div class="button-group" style="margin-bottom: 15px;">
                        <button onclick="downloadFiltered()">Download Filtered Data as CSV</button>
                    </div>
                    <div class="table-container">
                        <table id="filtered-table"></table>
                    </div>
                </div>
            </div>
            
            <!-- 6. Group By & Aggregation -->
            <div class="card">
                <h2 class="section-title">6. Group By & Aggregation</h2>
                <div class="grid-layout">
                    <div>
                        <label for="groupby-column">Group By Column (Categorical):</label>
                        <select id="groupby-column"></select>
                    </div>
                    <div>
                        <label for="aggregate-column">Value Column (Numeric):</label>
                        <select id="aggregate-column"></select>
                    </div>
                    <div>
                        <label for="aggregation-type">Aggregation:</label>
                        <select id="aggregation-type">
                            <option value="COUNT">COUNT</option>
                            <option value="SUM">SUM</option>
                            <option value="AVERAGE">AVERAGE</option>
                            <option value="MIN">MIN</option>
                            <option value="MAX">MAX</option>
                        </select>
                    </div>
                </div>
                <button onclick="runGroupBy()">Run Group By</button>

                <div id="groupby-results" style="margin-top: 20px; display: none;">
                    <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 10px;">Grouped Results</h3>
                    <div class="button-group" style="margin-bottom: 15px;">
                        <button onclick="downloadGrouped()">Download Grouped Data as CSV</button>
                    </div>
                    <div class="table-container">
                        <table id="groupby-table"></table>
                    </div>
                </div>
            </div>

            <!-- 7. Date / Time Trend Analysis -->
            <div class="card">
                <h2 class="section-title">7. Date / Time Trend Analysis & Chart</h2>
                <div class="grid-layout">
                    <div>
                        <label for="date-column-select">Date/Time Column:</label>
                        <select id="date-column-select"></select>
                    </div>
                    <div>
                        <label for="trend-value-column">Numeric Value Column:</label>
                        <select id="trend-value-column"></select>
                    </div>
                    <div>
                        <label for="trend-period">Group by Period:</label>
                        <select id="trend-period">
                            <option value="daily">Daily</option>
                            <option value="monthly">Monthly</option>
                            <option value="yearly">Yearly</option>
                        </select>
                    </div>
                </div>
                <button onclick="analyzeDateTrend()">Run Trend Analysis</button>

                <div id="trend-results" style="margin-top: 20px; display: none;">
                    <h3 style="font-size: 1.25rem; font-weight: 600; margin-bottom: 10px;">Time Series Trend</h3>
                    <div style="height: 300px; width: 100%; margin-bottom: 15px;">
                        <canvas id="trend-chart"></canvas>
                    </div>
                    <div class="table-container">
                        <table id="trend-table"></table>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Global variables for data storage and analysis state
        let rawData = []; // Array of arrays (data rows)
        let headers = []; // Array of column headers
        let typedData = []; // Array of objects with parsed types
        let columnTypes = {}; // Object mapping header -> type ('numeric', 'categorical', 'date')
        let stats = {}; // Object to store pre-calculated statistics
        let chartInstance; // Global reference for the Chart.js instance (visualization card)
        let trendChartInstance; // Global reference for the Chart.js instance (trend card)

        // Firebase-related global variables (Not strictly needed for this client-side app, but included as per standard instruction template)
        // Since this app must run without a backend/server, we will not use Firestore.
        // The user explicitly requested NO backend/server.
        const __app_id = 'csv-analyst'; 
        const __firebase_config = '{}';
        const __initial_auth_token = undefined; 

        // Utility function to display messages
        function displayMessage(message, type = 'success') {
            const statusDiv = document.getElementById('status-message');
            statusDiv.textContent = message;
            statusDiv.className = `status-message ${type}`;
            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.style.opacity = '1';
            }, 10);
        }

        function hideMessage() {
             const statusDiv = document.getElementById('status-message');
             statusDiv.style.opacity = '0';
             setTimeout(() => {
                statusDiv.style.display = 'none';
             }, 300);
        }

        // --- 1. CSV Upload & Parsing ---
        function processFile() {
            const fileInput = document.getElementById('csv-file');
            const delimiter = document.getElementById('delimiter').value || ',';
            const hasHeader = document.getElementById('has-header').value === 'true';
            
            if (fileInput.files.length === 0) {
                displayMessage('Please select a CSV file to upload.', 'error');
                return;
            }

            const file = fileInput.files[0];
            
            Papa.parse(file, {
                header: hasHeader,
                dynamicTyping: false,
                delimiter: delimiter,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        displayMessage(`Parsing finished with errors: ${results.errors.map(e => e.message).join('; ')}`, 'error');
                        return;
                    }
                    
                    headers = results.meta.fields || results.data[0].map((_, i) => `Column_${i + 1}`);
                    
                    // If no header, the first row is data
                    let dataRows = hasHeader ? results.data : results.data.slice(1);
                    if (!hasHeader) {
                        // In no-header mode, PapaParse returns an array of arrays
                        rawData = dataRows;
                    } else {
                        // In header mode, PapaParse returns an array of objects
                        rawData = dataRows.map(rowObj => headers.map(h => rowObj[h]));
                    }
                    
                    if (rawData.length === 0) {
                        displayMessage('The CSV file is empty or contains only headers.', 'error');
                        return;
                    }

                    detectTypes();
                    calculateAllStatistics();
                    renderPreviewTable(rawData);
                    updateControls();
                    document.getElementById('main-workbench').style.display = 'block';
                    displayMessage(`Successfully loaded and analyzed ${rawData.length} rows.`);
                }
            });
        }

        // --- 2. Data Type Detection & Preprocessing ---

        function isNumeric(value) {
            return !isNaN(parseFloat(value)) && isFinite(value);
        }

        function isDate(value) {
            if (typeof value !== 'string' || value.length < 6) return false;
            // Simple date check (MM/DD/YYYY, YYYY-MM-DD, etc.)
            const date = new Date(value);
            return !isNaN(date) && date.getFullYear() > 1900 && date.getFullYear() < 2100;
        }

        function detectTypes() {
            columnTypes = {};
            typedData = [];
            const numRows = rawData.length;
            
            // Heuristic: check a sample of rows
            const sampleSize = Math.min(50, numRows); 
            
            for (let i = 0; i < headers.length; i++) {
                let numericCount = 0;
                let dateCount = 0;
                
                for (let j = 0; j < sampleSize; j++) {
                    const value = rawData[j][i];
                    if (isNumeric(value)) {
                        numericCount++;
                    }
                    if (isDate(value)) {
                        dateCount++;
                    }
                }

                // Determine type based on majority of sample
                if (numericCount / sampleSize > 0.8) {
                    columnTypes[headers[i]] = 'numeric';
                } else if (dateCount / sampleSize > 0.8) {
                    columnTypes[headers[i]] = 'date';
                } else {
                    columnTypes[headers[i]] = 'categorical';
                }
            }

            // Convert rawData into a typed array of objects for easier manipulation
            typedData = rawData.map(row => {
                const rowObj = {};
                row.forEach((value, i) => {
                    const header = headers[i];
                    const type = columnTypes[header];
                    if (type === 'numeric') {
                        rowObj[header] = isNumeric(value) ? parseFloat(value) : null;
                    } else if (type === 'date') {
                        rowObj[header] = isDate(value) ? new Date(value) : null;
                    } else {
                        rowObj[header] = String(value);
                    }
                });
                return rowObj;
            });

            renderColumnTypes();
        }

        function renderColumnTypes() {
            const typesDiv = document.getElementById('column-types');
            typesDiv.innerHTML = '<strong>Detected Types:</strong> ';
            typesDiv.innerHTML += headers.map(h => 
                `<span class="badge" style="background-color: ${getTypeColor(columnTypes[h])}; color: white;">${h}: ${columnTypes[h]}</span>`
            ).join(' ');
        }

        function getTypeColor(type) {
            switch (type) {
                case 'numeric': return '#1d4ed8'; // Blue-700
                case 'date': return '#059669'; // Emerald-600
                case 'categorical': return '#f59e0b'; // Amber-500
                default: return '#6b7280'; // Gray-500
            }
        }
        
        // --- 3. Descriptive Statistics Helper Functions ---

        function getNumericValues(columnName) {
            return typedData.map(row => row[columnName]).filter(v => v !== null && isNumeric(v));
        }

        function calculateMean(arr) {
            if (arr.length === 0) return 0;
            return arr.reduce((a, b) => a + b, 0) / arr.length;
        }

        function calculateStandardDeviation(arr, mean) {
            if (arr.length < 2) return 0;
            const squareDiffs = arr.map(value => Math.pow(value - mean, 2));
            const avgSquareDiff = calculateMean(squareDiffs);
            return Math.sqrt(avgSquareDiff);
        }

        function calculateQuartiles(arr) {
            const sorted = [...arr].sort((a, b) => a - b);
            const n = sorted.length;
            
            const getQuantile = (p) => {
                const index = p * (n - 1);
                const l = Math.floor(index);
                const remainder = index - l;
                if (l < 0) return sorted[0];
                if (l >= n - 1) return sorted[n - 1];
                return sorted[l] + remainder * (sorted[l + 1] - sorted[l]);
            };

            const Q1 = getQuantile(0.25);
            const Q2 = getQuantile(0.5); // Median
            const Q3 = getQuantile(0.75);

            return { Q1, Q2, Q3, IQR: Q3 - Q1 };
        }

        function calculateMode(arr) {
            const counts = {};
            let maxCount = 0;
            let mode = [];

            for (const value of arr) {
                counts[value] = (counts[value] || 0) + 1;
                if (counts[value] > maxCount) {
                    maxCount = counts[value];
                }
            }

            for (const key in counts) {
                if (counts[key] === maxCount) {
                    mode.push(key);
                }
            }
            return mode.length === arr.length ? ['No mode'] : mode.join(', ');
        }
        
        function calculateStatsForColumn(columnName) {
            const type = columnTypes[columnName];
            const result = {};

            if (type === 'numeric') {
                const values = getNumericValues(columnName);
                if (values.length === 0) return { error: 'No numeric data found.' };

                const mean = calculateMean(values);
                const stdev = calculateStandardDeviation(values, mean);
                const { Q1, Q2: median, Q3, IQR } = calculateQuartiles(values);

                result.Count = values.length;
                result.Min = Math.min(...values);
                result.Max = Math.max(...values);
                result.Mean = mean.toFixed(2);
                result.Median = median.toFixed(2);
                result['Standard Deviation'] = stdev.toFixed(2);
                result['Q1 (25th Percentile)'] = Q1.toFixed(2);
                result['Q3 (75th Percentile)'] = Q3.toFixed(2);
                result.IQR = IQR.toFixed(2);
                result.Mode = calculateMode(values);

            } else if (type === 'categorical') {
                const values = typedData.map(row => row[columnName]).filter(v => v !== null);
                const counts = values.reduce((acc, val) => {
                    acc[val] = (acc[val] || 0) + 1;
                    return acc;
                }, {});

                result['Unique Values'] = Object.keys(counts).length;
                result['Total Count'] = values.length;
                result.Counts = counts; // Store counts for display
                
            } else if (type === 'date') {
                 const dates = typedData.map(row => row[columnName]).filter(d => d instanceof Date);
                 if (dates.length === 0) return { error: 'No valid date data found.' };
                 
                 const minDate = new Date(Math.min(...dates));
                 const maxDate = new Date(Math.max(...dates));

                 result['Date Count'] = dates.length;
                 result['Earliest Date'] = minDate.toLocaleDateString();
                 result['Latest Date'] = maxDate.toLocaleDateString();
            }

            return result;
        }

        function calculateAllStatistics() {
            stats = {};
            for (const header of headers) {
                stats[header] = calculateStatsForColumn(header);
            }
        }

        function renderStatistics() {
            const columnSelect = document.getElementById('stat-column-select');
            const columnName = columnSelect.value;
            const outputDiv = document.getElementById('statistics-output');
            
            if (!columnName || !stats[columnName]) {
                outputDiv.innerHTML = 'Select a column above.';
                return;
            }

            const columnStats = stats[columnName];
            let html = '';

            if (columnStats.error) {
                 html = `<p class="error">${columnStats.error}</p>`;
            } else if (columnTypes[columnName] === 'numeric' || columnTypes[columnName] === 'date') {
                html += '<table style="width: 100%;"><tbody>';
                for (const key in columnStats) {
                    if (key !== 'Counts') { // Skip counts for categorical
                         html += `<tr><td style="font-weight: 500;">${key}</td><td>${columnStats[key]}</td></tr>`;
                    }
                }
                html += '</tbody></table>';
            } else if (columnTypes[columnName] === 'categorical') {
                const counts = columnStats.Counts;
                
                html += `<p><strong>Unique Values:</strong> ${columnStats['Unique Values']} | <strong>Total Count:</strong> ${columnStats['Total Count']}</p>`;
                html += '<div class="table-container" style="max-height: 200px;"><table style="width: 100%;"><thead><tr><th>Value</th><th>Count</th></tr></thead><tbody>';
                
                // Sort counts by value (or count) for better visualization
                const sortedCounts = Object.entries(counts).sort(([, a], [, b]) => b - a);

                for (const [key, count] of sortedCounts) {
                    html += `<tr><td>${key}</td><td>${count}</td></tr>`;
                }
                html += '</tbody></table></div>';
            }

            outputDiv.innerHTML = html;
        }


        // --- UI Control Population (Dropdowns) ---
        function updateControls() {
            const numericHeaders = headers.filter(h => columnTypes[h] === 'numeric');
            const categoricalHeaders = headers.filter(h => columnTypes[h] === 'categorical');
            const dateHeaders = headers.filter(h => columnTypes[h] === 'date');
            
            // Reusable function to populate select elements
            const populateSelect = (id, options, type) => {
                const select = document.getElementById(id);
                select.innerHTML = `<option value="">-- Select a ${type} Column --</option>`;
                options.forEach(h => {
                    select.innerHTML += `<option value="${h}">${h}</option>`;
                });
            };

            // 3. Stats
            populateSelect('stat-column-select', headers, 'Data');
            
            // 4. Anomaly Detection
            populateSelect('anomaly-column-select', numericHeaders, 'Numeric');
            
            // 6. Group By
            populateSelect('groupby-column', categoricalHeaders, 'Categorical');
            populateSelect('aggregate-column', numericHeaders, 'Numeric');
            
            // 7. Date Trend
            populateSelect('date-column-select', dateHeaders, 'Date');
            populateSelect('trend-value-column', numericHeaders, 'Numeric');

            // 8. Charts
            populateSelect('chart-column-select', headers, 'Data');
        }

        // --- 4. Anomaly Detection Logic ---

        function detectAnomalies() {
            const columnName = document.getElementById('anomaly-column-select').value;
            const method = document.getElementById('anomaly-method').value;
            const resultsDiv = document.getElementById('anomaly-results');
            const countBadge = document.getElementById('anomaly-count-badge');
            
            resultsDiv.style.display = 'none';
            
            if (!columnName) {
                displayMessage('Please select a numeric column for anomaly detection.', 'error');
                return;
            }
            
            if (columnTypes[columnName] !== 'numeric') {
                displayMessage('Anomaly detection only works on numeric columns.', 'error');
                return;
            }

            const values = getNumericValues(columnName);
            if (values.length === 0) {
                 displayMessage('The selected column has no valid numeric data.', 'error');
                 return;
            }

            const anomalies = new Set(); // Use a Set to store anomalous row indices (original row index)
            
            // Z-score calculation
            const mean = calculateMean(values);
            const stdev = calculateStandardDeviation(values, mean);
            
            // IQR calculation
            const { Q1, Q3, IQR } = calculateQuartiles(values);
            const lowerBound = Q1 - 1.5 * IQR;
            const upperBound = Q3 + 1.5 * IQR;

            // Iterate through the original typed data to check each row
            typedData.forEach((row, index) => {
                const value = row[columnName];
                if (value === null || !isNumeric(value)) return;

                let isZscoreAnomaly = false;
                let isIqrAnomaly = false;

                // A. Z-score check
                if (stdev > 0) {
                    const zScore = Math.abs((value - mean) / stdev);
                    if (zScore > 3) { // |Z| > 3 Rule
                        isZscoreAnomaly = true;
                    }
                }

                // B. IQR check
                if (value < lowerBound || value > upperBound) {
                    isIqrAnomaly = true;
                }

                let isAnomaly = false;
                if (method === 'ZSCORE' && isZscoreAnomaly) {
                    isAnomaly = true;
                } else if (method === 'IQR' && isIqrAnomaly) {
                    isAnomaly = true;
                } else if (method === 'BOTH' && (isZscoreAnomaly || isIqrAnomaly)) {
                    isAnomaly = true;
                }

                if (isAnomaly) {
                    anomalies.add(index);
                }
            });

            const anomalousData = rawData.filter((_, index) => anomalies.has(index));
            const normalData = rawData.filter((_, index) => !anomalies.has(index));

            // Display anomaly count
            countBadge.textContent = anomalies.size;
            resultsDiv.style.display = 'block';

            // Display tables
            renderAnomalyTable(anomalousData);
            renderPreviewTable(rawData, anomalies); // Re-render preview to highlight anomalies
            
            displayMessage(`Anomaly detection completed. Found ${anomalies.size} anomalies using the ${method} method on column: ${columnName}.`);
        }
        
        // --- 2/4. Table Rendering ---
        function renderTable(tableId, data, highlightIndices = null) {
            const table = document.getElementById(tableId);
            table.innerHTML = ''; // Clear previous content

            if (data.length === 0) {
                table.innerHTML = `<tr><td colspan="${headers.length}" style="text-align: center;">No data to display.</td></tr>`;
                return;
            }

            // Header row
            let headerHtml = '<thead><tr>';
            headers.forEach(h => {
                headerHtml += `<th>${h}</th>`;
            });
            headerHtml += '</tr></thead>';
            table.innerHTML += headerHtml;

            // Data rows
            let bodyHtml = '<tbody>';
            data.forEach((row, rowIndex) => {
                const isAnomaly = highlightIndices && highlightIndices.has(rawData.indexOf(row));
                const rowClass = isAnomaly ? 'anomaly-row' : '';
                bodyHtml += `<tr class="${rowClass}">`;
                row.forEach(cell => {
                    bodyHtml += `<td>${cell !== null && cell !== undefined ? cell : ''}</td>`;
                });
                bodyHtml += '</tr>';
            });
            bodyHtml += '</tbody>';
            table.innerHTML += bodyHtml;
        }

        function renderPreviewTable(data, anomalyIndices = null) {
             // Total rows badge
            document.getElementById('total-rows-badge').textContent = `${data.length} Rows`;

            const table = document.getElementById('data-preview-table');
            table.innerHTML = ''; 

            if (data.length === 0) {
                table.innerHTML = `<tr><td colspan="${headers.length}" style="text-align: center;">No data available.</td></tr>`;
                return;
            }

            // Header row
            let headerHtml = '<thead><tr>';
            headers.forEach(h => {
                headerHtml += `<th>${h}</th>`;
            });
            headerHtml += '</tr></thead>';
            table.innerHTML += headerHtml;

            // Data rows
            let bodyHtml = '<tbody>';
            data.forEach((row, index) => {
                const isAnomaly = anomalyIndices && anomalyIndices.has(index);
                const rowClass = isAnomaly ? 'anomaly-row' : '';
                bodyHtml += `<tr class="${rowClass}">`;
                row.forEach(cell => {
                    bodyHtml += `<td>${cell !== null && cell !== undefined ? (cell instanceof Date ? cell.toLocaleDateString() : cell) : ''}</td>`;
                });
                bodyHtml += '</tr>';
            });
            bodyHtml += '</tbody>';
            table.innerHTML += bodyHtml;
        }
        
        function renderAnomalyTable(anomalousData) {
            // Since anomaly table only shows anomalies, we don't need the full row index map here.
            renderTable('anomaly-table', anomalousData);
        }
        
        // --- 5. Filtering Logic ---
        
        function applyFilter() {
            const expression = document.getElementById('filter-expression').value.trim();
            const resultsDiv = document.getElementById('filter-results');
            const countBadge = document.getElementById('filtered-count-badge');
            
            resultsDiv.style.display = 'none';
            if (!expression) {
                displayMessage('Please enter a filter expression.', 'error');
                return;
            }

            let filteredRawData = [];
            let filterCount = 0;
            
            // Loop through each row of the typed data
            typedData.forEach((rowObj, index) => {
                // Create a dynamic context for the filter expression evaluation
                // This makes column names available as variables (e.g., Age, Country)
                const context = {};
                for (const h of headers) {
                    let value = rowObj[h];
                    // Convert Dates to String for easier comparison in JS expressions
                    if (value instanceof Date) {
                        value = value.toISOString(); 
                    }
                    context[h] = value;
                }

                // Function to safely evaluate the filter expression
                const filterFunction = new Function('context', `
                    with (context) {
                        try {
                            return ${expression};
                        } catch (e) {
                            return false; 
                        }
                    }
                `);

                try {
                    if (filterFunction(context)) {
                        filteredRawData.push(rawData[index]);
                        filterCount++;
                    }
                } catch (e) {
                    // This catches syntax errors in the user's expression
                    displayMessage(`Filter expression error: ${e.message}. Please check your syntax.`, 'error');
                    filteredRawData = []; // Clear results on error
                    return;
                }
            });

            // Display results
            countBadge.textContent = filterCount;
            resultsDiv.style.display = 'block';
            renderTable('filtered-table', filteredRawData);
            displayMessage(`Filter applied. Found ${filterCount} rows matching the expression.`);
        }
        
        function resetFilter() {
            document.getElementById('filter-expression').value = '';
            document.getElementById('filter-results').style.display = 'none';
            displayMessage('Filter cleared.');
        }

        // --- 6. Group By & Aggregation Logic ---

        function runGroupBy() {
            const groupbyCol = document.getElementById('groupby-column').value;
            const aggregateCol = document.getElementById('aggregate-column').value;
            const aggType = document.getElementById('aggregation-type').value;
            const resultsDiv = document.getElementById('groupby-results');
            
            resultsDiv.style.display = 'none';

            if (!groupbyCol || !aggregateCol || !aggType) {
                displayMessage('Please select a Group By column, an Aggregate column, and an Aggregation type.', 'error');
                return;
            }

            if (columnTypes[groupbyCol] !== 'categorical') {
                displayMessage('Group By column must be categorical.', 'error');
                return;
            }
            if (columnTypes[aggregateCol] !== 'numeric') {
                displayMessage('Aggregate column must be numeric.', 'error');
                return;
            }
            
            const groups = {}; // Key: GroupBy value, Value: Array of numeric values

            typedData.forEach(row => {
                const groupKey = String(row[groupbyCol]);
                const aggValue = row[aggregateCol];

                if (aggValue !== null && isNumeric(aggValue)) {
                    if (!groups[groupKey]) {
                        groups[groupKey] = [];
                    }
                    groups[groupKey].push(aggValue);
                }
            });

            const groupedResults = [];
            const resultHeaders = [groupbyCol, 'Count', aggType];

            for (const key in groups) {
                const values = groups[key];
                let resultValue;

                switch (aggType) {
                    case 'COUNT':
                        resultValue = values.length;
                        break;
                    case 'SUM':
                        resultValue = values.reduce((a, b) => a + b, 0).toFixed(2);
                        break;
                    case 'AVERAGE':
                        resultValue = calculateMean(values).toFixed(2);
                        break;
                    case 'MIN':
                        resultValue = Math.min(...values).toFixed(2);
                        break;
                    case 'MAX':
                        resultValue = Math.max(...values).toFixed(2);
                        break;
                }

                groupedResults.push([key, values.length, resultValue]);
            }
            
            // Display results
            document.getElementById('groupby-results').style.display = 'block';
            renderGroupbyTable(resultHeaders, groupedResults);
            displayMessage(`Group By analysis completed for ${groupbyCol}.`);
        }
        
        function renderGroupbyTable(resultHeaders, groupedResults) {
            const table = document.getElementById('groupby-table');
            table.innerHTML = '';

            // Header row
            let headerHtml = '<thead><tr>';
            resultHeaders.forEach(h => {
                headerHtml += `<th>${h}</th>`;
            });
            headerHtml += '</tr></thead>';
            table.innerHTML += headerHtml;

            // Data rows
            let bodyHtml = '<tbody>';
            groupedResults.forEach(row => {
                bodyHtml += `<tr>`;
                row.forEach(cell => {
                    bodyHtml += `<td>${cell}</td>`;
                });
                bodyHtml += '</tr>';
            });
            bodyHtml += '</tbody>';
            table.innerHTML += bodyHtml;
        }

        // --- 7. Date / Time Trend Analysis Logic ---

        function analyzeDateTrend() {
            const dateCol = document.getElementById('date-column-select').value;
            const valueCol = document.getElementById('trend-value-column').value;
            const period = document.getElementById('trend-period').value;
            
            document.getElementById('trend-results').style.display = 'none';

            if (!dateCol || !valueCol) {
                displayMessage('Please select both a Date and a Numeric Value column for trend analysis.', 'error');
                return;
            }
            
            if (columnTypes[dateCol] !== 'date' || columnTypes[valueCol] !== 'numeric') {
                displayMessage('Invalid column types for trend analysis. Must be Date and Numeric.', 'error');
                return;
            }
            
            const trendData = {}; // Key: date string, Value: { sum, count }

            typedData.forEach(row => {
                const date = row[dateCol];
                const value = row[valueCol];
                
                if (date instanceof Date && value !== null && isNumeric(value)) {
                    let groupKey;
                    
                    if (period === 'daily') {
                        groupKey = date.toISOString().split('T')[0];
                    } else if (period === 'monthly') {
                        groupKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-01`;
                    } else if (period === 'yearly') {
                        groupKey = `${date.getFullYear()}-01-01`;
                    }
                    
                    if (!trendData[groupKey]) {
                        trendData[groupKey] = { sum: 0, count: 0 };
                    }
                    trendData[groupKey].sum += value;
                    trendData[groupKey].count += 1;
                }
            });

            const results = Object.entries(trendData)
                .map(([dateKey, data]) => ({
                    date: dateKey,
                    average: data.sum / data.count,
                    count: data.count
                }))
                .sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort by date

            if (results.length === 0) {
                 displayMessage('No valid date/numeric pairs found for trend analysis.', 'error');
                 return;
            }
            
            renderTrendTable(results);
            renderTrendChart(results, period);
            document.getElementById('trend-results').style.display = 'block';
            displayMessage(`Time series trend analysis completed, grouped by ${period}.`);
        }

        function renderTrendTable(results) {
            const table = document.getElementById('trend-table');
            table.innerHTML = '';
            
            const resultHeaders = ['Period', 'Average Value', 'Count'];

            // Header row
            let headerHtml = '<thead><tr>';
            resultHeaders.forEach(h => {
                headerHtml += `<th>${h}</th>`;
            });
            headerHtml += '</tr></thead>';
            table.innerHTML += headerHtml;

            // Data rows
            let bodyHtml = '<tbody>';
            results.forEach(row => {
                bodyHtml += `<tr>
                    <td>${row.date}</td>
                    <td>${row.average.toFixed(2)}</td>
                    <td>${row.count}</td>
                </tr>`;
            });
            bodyHtml += '</tbody>';
            table.innerHTML += bodyHtml;
        }

        function renderTrendChart(results, period) {
            if (trendChartInstance) {
                trendChartInstance.destroy();
            }

            const ctx = document.getElementById('trend-chart').getContext('2d');
            const data = {
                labels: results.map(r => r.date),
                datasets: [{
                    label: `Average Value Trend`,
                    data: results.map(r => r.average),
                    borderColor: varToColor('primary-color'),
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    tension: 0.4,
                    fill: true
                }]
            };
            
            // Map period to Chart.js time unit
            let timeUnit = 'day';
            if (period === 'monthly') timeUnit = 'month';
            if (period === 'yearly') timeUnit = 'year';

            trendChartInstance = new Chart(ctx, {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: timeUnit,
                                tooltipFormat: 'P', // locale-specific date format
                            },
                            title: {
                                display: true,
                                text: 'Period'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Average Value'
                            }
                        }
                    },
                    plugins: {
                        legend: { display: true }
                    }
                }
            });
        }
        
        // --- 8. Visualizations (Charts) ---
        function varToColor(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(`--${varName}`).trim();
        }

        function renderVisualization() {
            const columnName = document.getElementById('chart-column-select').value;
            if (chartInstance) {
                chartInstance.destroy();
            }

            if (!columnName) return;

            const type = columnTypes[columnName];
            const ctx = document.getElementById('data-chart').getContext('2d');
            
            if (type === 'numeric') {
                const values = getNumericValues(columnName);
                if (values.length === 0) return;
                
                // Simple Histogram Logic: Divide data into 10 equal bins
                const min = Math.min(...values);
                const max = Math.max(...values);
                const range = max - min;
                const numBins = 10;
                const binSize = range / numBins;
                
                const bins = new Array(numBins).fill(0);
                const labels = [];

                for (let i = 0; i < numBins; i++) {
                    const lower = min + i * binSize;
                    const upper = min + (i + 1) * binSize;
                    labels.push(`${lower.toFixed(1)}-${upper.toFixed(1)}`);
                }
                
                values.forEach(v => {
                    let binIndex = Math.floor((v - min) / binSize);
                    if (binIndex >= numBins) binIndex = numBins - 1; // Put max value in the last bin
                    if (binIndex < 0) binIndex = 0;
                    bins[binIndex]++;
                });

                chartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `Frequency of ${columnName}`,
                            data: bins,
                            backgroundColor: varToColor('primary-color'),
                            borderColor: varToColor('primary-color'),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: { display: true, text: `Histogram for ${columnName}` }
                        },
                        scales: {
                            y: { beginAtZero: true, title: { display: true, text: 'Frequency' } },
                            x: { title: { display: true, text: 'Value Range' } }
                        }
                    }
                });

            } else if (type === 'categorical') {
                const counts = stats[columnName]?.Counts;
                if (!counts) return;

                const labels = Object.keys(counts);
                const dataValues = Object.values(counts);

                chartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Count',
                            data: dataValues,
                            backgroundColor: labels.map((_, i) => `hsl(${i * (360 / labels.length)}, 70%, 50%)`),
                            borderColor: '#ffffff',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: { display: true, text: `Bar Chart of Counts for ${columnName}` }
                        },
                        scales: {
                            y: { beginAtZero: true, title: { display: true, text: 'Count' } },
                            x: { title: { display: true, text: columnName } }
                        }
                    }
                });
            } else if (type === 'date') {
                displayMessage('For date trend visualization, please use the "7. Date / Time Trend Analysis" section.', 'error');
            }
        }
        
        // --- 9. Export Functions ---
        
        function downloadCSV(data, filename) {
            if (data.length === 0) {
                displayMessage(`No data to export for ${filename}.`, 'error');
                return;
            }

            // Prepend headers to the data array
            const dataToExport = [headers, ...data];
            
            // PapaParse unparse to generate CSV string
            const csv = Papa.unparse(dataToExport);

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                displayMessage(`Successfully prepared and downloaded ${filename}.`);
            }
        }

        function downloadAnomalies() {
            // Need to retrieve the currently detected anomalies
            const anomalyTable = document.getElementById('anomaly-table');
            const anomalyRows = Array.from(anomalyTable.querySelectorAll('tbody tr'));
            
            if (anomalyRows.length === 0 || anomalyRows[0].textContent.includes('No data to display')) {
                displayMessage('No anomalies have been detected or they are empty.', 'error');
                return;
            }
            
            // Extract data from the table (to ensure we get the currently displayed set)
            const data = anomalyRows.map(row => 
                Array.from(row.querySelectorAll('td')).map(td => td.textContent)
            );

            if (data.length === 0) return;
            downloadCSV(data, 'anomalies_export.csv');
        }

        function downloadFiltered() {
            const filteredTable = document.getElementById('filtered-table');
            const filteredRows = Array.from(filteredTable.querySelectorAll('tbody tr'));
            
            if (filteredRows.length === 0 || filteredRows[0].textContent.includes('No data to display')) {
                displayMessage('No filtered data to download. Apply a filter first.', 'error');
                return;
            }
            
            const data = filteredRows.map(row => 
                Array.from(row.querySelectorAll('td')).map(td => td.textContent)
            );
            
            if (data.length === 0) return;
            downloadCSV(data, 'filtered_export.csv');
        }

        function downloadGrouped() {
            const groupedTable = document.getElementById('groupby-table');
            const groupedRows = Array.from(groupedTable.querySelectorAll('tbody tr'));
            
            if (groupedRows.length === 0 || groupedRows[0].textContent.includes('No data to display')) {
                displayMessage('No grouped data to download. Run a Group By operation first.', 'error');
                return;
            }

            // Get headers from the table (since GroupBy headers are custom)
            const customHeaders = Array.from(groupedTable.querySelectorAll('thead th')).map(th => th.textContent);
            
            // Extract data
            const data = groupedRows.map(row => 
                Array.from(row.querySelectorAll('td')).map(td => td.textContent)
            );
            
            // Manually unparse with custom headers
            const csv = Papa.unparse([customHeaders, ...data]);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'grouped_export.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                displayMessage('Successfully prepared and downloaded grouped_export.csv.');
            }
        }

        // Initialize UI State
        document.addEventListener('DOMContentLoaded', () => {
            // Hide the main workbench until data is loaded
            document.getElementById('main-workbench').style.display = 'none';
        });

    </script>
</body>
</html>
